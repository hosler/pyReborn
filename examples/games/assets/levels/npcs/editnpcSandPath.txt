if (playerenters) {
  this.lastpx = -1000;
}
if (playerenters || timeout) {
  if (mousebuttons%2>=1) {
    if (this.lastpx>-1000) {
      dx = (mousex-this.lastpx);
      dy = (mousey-this.lastpy);
      dist = (abs(dx)>abs(dy)? abs(dx) : abs(dy));
      for (di=0; di<dist; di++) {
        px = this.lastpx + (dx*di/dist);
        py = this.lastpy + (dy*di/dist);
        laypath();
      }
    }
    px = mousex;
    py = mousey;
    laypath();
    this.lastpx = px;
    this.lastpy = py;
  } else
    this.lastpx = -1000;
  timeout = 0.05;
}
function laypath() {
  sandtiles = {0xaa,0xab,0x12d,0x8,0xf};
  grasstiles = {0x0,0x1,0x10,0x1ff,0x3ff,0x7ff,0x835,0x836,0x837};
  sandspot = {
    0x176,0x166,0x177,
    0x1a7, 0xaa,0x197,
    0x188,0x178,0x169
    };
  grassspot = {
    0x168,0x178,0x189,
    0x197,0x7ff,0x1a7,
    0x187,0x166,0x186
    };
  sandcornernwse = 0xfe9;
  sandcornernesw = 0xff9;
  allcornertiles = {0x176,0x166,0x167,0x177,0x1a7,0xaa,0x197,0x188,0x178,0x179,0x169,
    0x168,0x189,0x187,0x186,0xfe9,0xff9};

  // Check if can lay a sand path here
  if (tiles[px,py] in sandtiles) return;
  for (tx=px-1; tx<=px+1; tx++) for (ty=py-1; ty<=py+1; ty++) {
    if (tiles[tx,ty] in sandtiles) continue;
    checkgrassorborder();
    if (isok==false) return;
  }

  // Put sand on the mouse position
  tiles[px,py] = sandtiles[int(random(0,5))];

  // Calculate the tiles around the mouse position
  for (tx=px-1; tx<=px+1; tx++) for (ty=py-1; ty<=py+1; ty++) {
    if ((tx==px && ty==py) || tiles[tx,ty] in sandtiles) continue;

    // Check which tiles around this tile are sand tiles
    sandn  = (tiles[tx  ,ty-1] in sandtiles);
    sandnw = (tiles[tx-1,ty-1] in sandtiles);
    sandw  = (tiles[tx-1,ty  ] in sandtiles);
    sandsw = (tiles[tx-1,ty+1] in sandtiles);
    sands  = (tiles[tx  ,ty+1] in sandtiles);
    sandse = (tiles[tx+1,ty+1] in sandtiles);
    sande  = (tiles[tx+1,ty  ] in sandtiles);
    sandne = (tiles[tx+1,ty-1] in sandtiles);
    if (sandnw+sandne==2) sandn = true;
    if (sandnw+sandsw==2) sandw = true;
    if (sandsw+sandse==2) sands = true;
    if (sandse+sandne==2) sande = true;

    // Get the right sand corner tile depending on
    // in which directions sand was found
    if (sandn+sands==2 || sandw+sande==2 ||
        sandn+sandw+sandse==3 || sandw+sands+sandne==3 || sands+sande+sandnw==3 || sande+sandn+sandsw==3)
      newtile = sandtiles[0];
    else if (sandn+sandw+sands+sande==2) {
      if (sandn+sandw==2) newtile = grassspot[0+0*3];
      else if (sandw+sands==2) newtile = grassspot[0+2*3];
      else if (sands+sande==2) newtile = grassspot[2+2*3];
      else newtile = grassspot[2+0*3];
    } else if (sandn+sandw+sands+sande==1) {
      if (sandn+sandse==2 || sande+sandnw==2) newtile = grassspot[2+0*3];
      else if (sandn+sandsw==2 || sandw+sandne==2) newtile = grassspot[0+0*3];
      else if (sands+sandnw==2 || sandw+sandse==2) newtile = grassspot[0+2*3];
      else if (sands+sandne==2 || sande+sandsw==2) newtile = grassspot[2+2*3];
      else if (sandn==1) newtile = grassspot[1+0*3] + (tx%2); // 2 tiles for north
      else if (sandw==1) newtile = grassspot[0+1*3];
      else if (sands==1) newtile = grassspot[1+2*3] + (tx%2); // 2 tiles for south
      else newtile = grassspot[2+1*3];
    } else if (sandnw+sandne+sandsw+sandse==2) {
      if (sandnw+sandse==2) newtile = sandcornernwse;
      else if (sandne+sandsw==2) newtile = sandcornernesw;
    } else if (sandnw+sandne+sandsw+sandse==1) {
      if (sandnw==1) newtile = sandspot[2+2*3];
      else if (sandsw==1) newtile = sandspot[2+0*3];
      else if (sandse==1) newtile = sandspot[0+0*3];
      else newtile = sandspot[0+2*3];
    }

    // Write the tile
    tiles[tx,ty] = newtile;
  }

  // Redraw the level on the mouse position
  updateboard px-1,py-1,3,3;
}
function checkgrassorborder() {
  isok = ((tiles[tx,ty] in grasstiles) || (tiles[tx,ty] in allcornertiles));
}
